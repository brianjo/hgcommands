"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6439],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>f});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},m=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),d=c(n),f=o,p=d["".concat(l,".").concat(f)]||d[f]||u[f]||s;return n?r.createElement(p,a(a({ref:t},m),{},{components:n})):r.createElement(p,a({ref:t},m))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,a=new Array(s);a[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,a[1]=i;for(var c=2;c<s;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9825:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var r=n(7462),o=(n(7294),n(3905));const s={},a=void 0,i={unversionedId:"Commands/resolve",id:"Commands/resolve",title:"resolve",description:"",source:"@site/docs/Commands/resolve.md",sourceDirName:"Commands",slug:"/Commands/resolve",permalink:"/hgcommands/docs/Commands/resolve",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Commands/resolve.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"reset",permalink:"/hgcommands/docs/Commands/reset"},next:{title:"revert",permalink:"/hgcommands/docs/Commands/revert"}},l={},c=[],m={toc:c};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"hg resolve \\[OPTION\\]... \\[FILE\\]...\n\naliases: reso\n\nredo merges or set/view the merge status of files\n\n    Merges with unresolved conflicts are often the result of non-interactive\n    merging using the \"internal:merge\" configuration setting, or a command-\n    line merge tool like \"diff3\". The resolve command is used to manage the\n    files involved in a merge, after 'hg merge' has been run, and before 'hg\n    commit' is run (i.e. the working directory must have two parents). See 'hg\n    help merge-tools' for information on configuring merge tools.\n\n    The resolve command can be used in the following ways:\n\n    - 'hg resolve [--tool TOOL] FILE...': attempt to re-merge the specified\n      files, discarding any previous merge attempts. Re-merging is not\n      performed for files already marked as resolved. Use \"--all/-a\" to select\n      all unresolved files. \"--tool\" can be used to specify the merge tool\n      used for the given files. It overrides the HGMERGE environment variable\n      and your configuration files.  Previous file contents are saved with a\n      \".orig\" suffix.\n    - 'hg resolve -m [FILE]': mark a file as having been resolved (e.g. after\n      having manually fixed-up the files). The default is to mark all\n      unresolved files.\n    - 'hg resolve -u [FILE]...': mark a file as unresolved. The default is to\n      mark all resolved files.\n    - 'hg resolve -l': list files which had or still have conflicts. In the\n      printed list, \"U\" = unresolved and \"R\" = resolved. You can use\n      \"set:unresolved()\" or \"set:resolved()\" to filter the list. See 'hg help\n      filesets' for details.\n\n    Note:\n       Mercurial will not let you commit files with unresolved merge\n       conflicts. You must use 'hg resolve -m ...' before you can commit after\n       a conflicting merge.\n\n    Returns 0 on success, 1 if any files fail a resolve attempt.\n\nOptions (\\[+\\] can be repeated):\n\n-a --all select all unresolved files -l --list list state of files\nneeding merge -m --mark mark files as resolved -u --unmark mark files as\nunresolved -n --no-status hide status prefix --root-relative show paths\nrelative to repo root -t --tool VALUE specify merge tool -I --include\nPATTERN \\[+\\] include names matching the given patterns -X --exclude\nPATTERN \\[+\\] exclude names matching the given patterns --skip skip\nmerge driver\n\n(some details hidden, use --verbose to show complete help)\n")))}u.isMDXComponent=!0}}]);