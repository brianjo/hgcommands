"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7536],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>p});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),m=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=m(e.components);return o.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},l=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),l=m(n),p=r,b=l["".concat(c,".").concat(p)]||l[p]||u[p]||a;return n?o.createElement(b,s(s({ref:t},d),{},{components:n})):o.createElement(b,s({ref:t},d))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=l;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var m=2;m<a;m++)s[m]=n[m];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}l.displayName="MDXCreateElement"},5833:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>m});var o=n(7462),r=(n(7294),n(3905));const a={},s=void 0,i={unversionedId:"Commands/bisect",id:"Commands/bisect",title:"bisect",description:"",source:"@site/docs/Commands/bisect.md",sourceDirName:"Commands",slug:"/Commands/bisect",permalink:"/hgcommands/docs/Commands/bisect",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Commands/bisect.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"backout",permalink:"/hgcommands/docs/Commands/backout"},next:{title:"blackbox",permalink:"/hgcommands/docs/Commands/blackbox"}},c={},m=[],d={toc:m};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"hg bisect \\[-gbsr\\] \\[-U\\] \\[-S\\] \\[-c CMD\\] \\[REV\\]\n\naliases: bi\n\nsubdivision search of commits\n\n    This command helps to find commits which introduce problems. To use, mark\n    the earliest commit you know exhibits the problem as bad, then mark the\n    latest commit which is free from the problem as good. Bisect will update\n    your working directory to a revision for testing (unless the -U/--noupdate\n    option is specified). Once you have performed tests, mark the working\n    directory as good or bad, and bisect will either update to another\n    candidate commit or announce that it has found the bad revision. The\n    command will also skip commits, which don't contain changes in the sparse\n    profile, unless the -S/--nosparseskip option is specified.\n\n    As a shortcut, you can also use the revision argument to mark a revision\n    as good or bad without checking it out first.\n\n    If you supply a command, it will be used for automatic bisection. The\n    environment variable HG_NODE will contain the ID of the commit being\n    tested. The exit status of the command will be used to mark revisions as\n    good or bad: status 0 means good, 125 means to skip the revision, 127\n    (command not found) will abort the bisection, and any other non-zero exit\n    status means the revision is bad.\n\n    Returns 0 on success.\n\nOptions:\n\n-r --reset reset bisect state -g --good mark changeset good -b --bad\nmark changeset bad -s --skip skip testing changeset -e --extend extend\nthe bisect range -c --command CMD use command to check changeset state\n-U --noupdate do not update to target -S --nosparseskip do not skip\nchangesets with no changes in sparse profile\n\n(some details hidden, use --verbose to show complete help)\n")))}u.isMDXComponent=!0}}]);