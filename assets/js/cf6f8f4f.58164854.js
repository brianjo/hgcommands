"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6828],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=l(n),d=o,f=u["".concat(s,".").concat(d)]||u[d]||m[d]||i;return n?r.createElement(f,a(a({ref:t},p),{},{components:n})):r.createElement(f,a({ref:t},p))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=u;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,a[1]=c;for(var l=2;l<i;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1770:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var r=n(7462),o=(n(7294),n(3905));const i={},a=void 0,c={unversionedId:"Commands/cat",id:"Commands/cat",title:"cat",description:"",source:"@site/docs/Commands/cat.md",sourceDirName:"Commands",slug:"/Commands/cat",permalink:"/docs/Commands/cat",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Commands/cat.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"bundle",permalink:"/docs/Commands/bundle"},next:{title:"chistedit",permalink:"/docs/Commands/chistedit"}},s={},l=[],p={toc:l};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'hg cat \\[OPTION\\]... FILE...\n\noutput the current or given revision of files\n\n    Print the specified files as they were at the given revision. If no\n    revision is given, the parent of the working directory is used.\n\n    Output may be to a file, in which case the name of the file is given using\n    a format string. The formatting rules as follows:\n\n    "%%"          literal "%" character\n    "%s"          basename of file being printed\n    "%d"          dirname of file being printed, or \'.\' if in repository root\n    "%p"          root-relative path name of file being printed\n    "%H"          commit hash (40 hexadecimal digits)\n    "%R"          commit revision number\n    "%h"          short-form commit hash (12 hexadecimal digits)\n    "%r"          zero-padded commit revision number\n    "%b"          basename of the exporting repository\n\n    Returns 0 on success.\n\nOptions (\\[+\\] can be repeated):\n\n-o --output FORMAT print output to file with formatted name -r --rev REV\nprint the given revision --decode apply any matching decode filter -I\n--include PATTERN \\[+\\] include names matching the given patterns -X\n--exclude PATTERN \\[+\\] exclude names matching the given patterns\n\n(some details hidden, use --verbose to show complete help)\n')))}m.isMDXComponent=!0}}]);